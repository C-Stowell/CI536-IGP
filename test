package ci583.receiver;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.PriorityQueue;

public class PReceiver extends ModRegReceiver {
    private PriorityQueue<ModuleRegister> processQueue;
    private long quantum;

    public PReceiver(long quantum) {
        super(quantum);
        this.quantum = quantum;
        // Initialize the priority queue with a custom comparator
        Comparator<ModuleRegister> comparator = (m1, m2) -> {
            // Compare the priorities of m1 and m2
            if (m1.getPriority() < m2.getPriority()) {
                return -1; // m1 has lower priority than m2
            } else if (m1.getPriority() > m2.getPriority()) {
                return 1; // m1 has higher priority than m2
            } else {
                return -1; // Prioritize m1 over m2 if priorities are equal
            }
        };
        processQueue = new PriorityQueue<>(comparator);
    }

    @Override
    public void enqueue(ModuleRegister m) {
        processQueue.offer(m);
    }

    @Override
    public List<ModuleRegister> startRegistration() {
        List<ModuleRegister> completedProcesses = new ArrayList<>();
        while (!processQueue.isEmpty()) {
            ModuleRegister currentProcess = processQueue.poll();
            System.out.println("Running process: " + currentProcess.getName());
            Thread.State state = currentProcess.getState();
            switch (state) {
                case NEW:
                    currentProcess.start(); // Start the process if it's in the NEW state
                    try {
                        Thread.sleep(quantum); // Sleep for quantum milliseconds
                    } catch (InterruptedException e) {
                        // Handle interruption
                        e.printStackTrace();
                    }
                    processQueue.offer(currentProcess); // Put the process back into the queue
                    break;
                case TERMINATED:
                    completedProcesses.add(currentProcess); // Add terminated process to the completed list
                    break;
                default:
                    currentProcess.interrupt(); // Interrupt the process
                    try {
                        Thread.sleep(quantum); // Sleep for quantum milliseconds
                    } catch (InterruptedException e) {
                        // Handle interruption
                        e.printStackTrace();
                    }
                    processQueue.offer(currentProcess); // Put the process back into the queue
                    break;

            }
            System.out.println(completedProcesses);
        }
        return completedProcesses;
    }
}

