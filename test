package ci583.receiver;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class MLFQReceiver extends ModRegReceiver {
    private List<ModuleRegister> youngProcesses;
    private List<ModuleRegister> oldProcesses;
    private long quantum;

    public MLFQReceiver(long quantum) {
        super(quantum);
        this.quantum = quantum;
        youngProcesses = Collections.synchronizedList(new ArrayList<>()); // Ensure synchronization
        oldProcesses = Collections.synchronizedList(new ArrayList<>()); // Ensure synchronization
    }

    @Override
    public void enqueue(ModuleRegister m) {
        synchronized (this) { // Ensure synchronized access
            youngProcesses.add(m);
        }
    }

    @Override
    public List<ModuleRegister> startRegistration() {
        List<ModuleRegister> results = new ArrayList<>();
        List<ModuleRegister> startedProcesses = new ArrayList<>();

        while (!youngProcesses.isEmpty() || !oldProcesses.isEmpty()) {
            synchronized (this) { // Ensure synchronized access
                if (!youngProcesses.isEmpty()) {
                    ModuleRegister process = youngProcesses.remove(0);
                    Thread.State state = process.getState();
                    if (state == Thread.State.NEW) {
                        process.start();
                        startedProcesses.add(process);
                        try {
                            Thread.sleep(quantum);
                        } catch (InterruptedException ignored) {
                            // Handle interruption if needed
                        }
                        oldProcesses.add(process);
                    } else if (state == Thread.State.TERMINATED) {
                        results.add(process);
                    } else {
                        oldProcesses.add(process);
                    }
                } else if (!oldProcesses.isEmpty()) {
                    ModuleRegister process = oldProcesses.remove(0);
                    Thread.State state = process.getState();
                    if (state == Thread.State.NEW) {
                        process.start();
                        startedProcesses.add(process);
                        try {
                            Thread.sleep(quantum);
                        } catch (InterruptedException ignored) {
                            // Handle interruption if needed
                        }
                        youngProcesses.add(process);
                    } else if (state == Thread.State.TERMINATED) {
                        results.add(process);
                    } else {
                        youngProcesses.add(process);
                    }
                }
            }
        }

        for (ModuleRegister process : startedProcesses) {
            if (results.contains(process)) {
                continue;
            }
            results.add(process);
        }

        return results;
    }
}
