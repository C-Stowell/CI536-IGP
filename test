package ci583.receiver;

import java.util.ArrayList;
import java.util.List;

public class RRReceiver extends ModRegReceiver {

    // List to hold module registration processes
    private ArrayList<ModuleRegister> queue;

    /**
     * Create a new RRReceiver with the given quantum. The constructor needs to call the constructor
     * of the superclass, then initialise the list of processes.
     *
     * @param quantum amount of time to run RRReceiver
     */
    public RRReceiver(long quantum) {
        super(quantum);
        // Initialize the list of processes
        queue = new ArrayList<>();
    }

    /**
     * Add a ModuleRegister process to the queue, to be scheduled for registration
     */
    @Override
    public void enqueue(ModuleRegister m) {
        // Add the process to the queue
        queue.add(m);
    }

    /**
     * Schedule the processes, start registration. This method needs to:
     * + create an empty list which will hold the completed processes. This will be the
     * return value of the method.
     * + while the queue is not empty:
     * - take the next process from the queue and get its State.
     * - if the state is NEW, start the process then sleep for QUANTUM milliseconds
     * then put the process at the back of the queue.
     * - if the state is TERMINATED, add it to the results list.
     * - if the state is anything else then interrupt the process to wake it up then
     * sleep for QUANTUM milliseconds, then put the process at the back of the queue.
     * + when the queue is empty, return the list of completed processes.
     *
     * @return
     */
    @Override
    public List<ModuleRegister> startRegistration() {
        ArrayList<ModuleRegister> results = new ArrayList<>();

        while (!queue.isEmpty()) {
            ModuleRegister process = queue.remove(0); // Take the next process from the queue
            Thread.State state = process.getState(); // Get the state of the process

            if (state == Thread.State.NEW) {
                process.start(); // Start the process
                try {
                    Thread.sleep(ModRegReceiver.QUANTUM); // Sleep for QUANTUM milliseconds
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                queue.add(process); // Put the process at the back of the queue
            } else if (state == Thread.State.TERMINATED) {
                results.add(process); // Add the process to the results list
            } else {
                process.interrupt(); // Interrupt the process to wake it up
                try {
                    Thread.sleep(ModRegReceiver.QUANTUM); // Sleep for QUANTUM milliseconds
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                queue.add(process); // Put the process at the back of the queue
            }
            System.out.println(results);
        }

        return results; // Return the list of completed processes

    }

}

